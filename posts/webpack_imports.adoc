= Cleaner Imports With Webpack Aliases
D10f <devontheroof@pm.me>
v2, 2022-01-04
:license-url: https://creativecommons.org/licenses/by-sa/4.0/
:license-title: CC BY-SA 4.0
:doctype: article
:description: Maintain imported modules under control using aliases. No more messiness because of insane relative paths!
:keywords: javascript typescript webpack
:technologies: javascript typescript webpack vite
:source-highlighter: pygments
:icons: font
:toc:

Eventually, code grows large enough that when you open a file all you see is a bunch of dependencies being imported to it. Not only does it look ugly, but if you ever need to move one file that uses this particular component the import statement will also change and that is a major waste of time. To tackle this, Webpack has the option to use aliases which make importing files a lot more straightforward.

== Create An Alias On The Configuration

To do so update your current Webpack configuration file as the following example. You can of course name the "keys" however you want and point them to any other directory within your project.

In your Webpack configuration file you can create an alias object where you define the suffixes, and the path they represent. You can choose whatever name you like, although using "@" in front is a common convention for this.

[source,javascript,title="webpack.config.js"]
----
const path = require('path');
module.exports = {
    resolve: {
        alias: {
            '@components': path.resolve(__dirname, 'src/components'),
            '@hooks': path.resolve(__dirname, 'src/hooks'),
            '@services': path.resolve(__dirname, 'src/services'),
            '@assets': path.resolve(__dirname, 'src/assets'),
            '@utils': path.resolve(__dirname, 'src/utils'),
        },
    },
};
----

== TypeScript Support

When dealing with TypeScript all that is required is to update the `tsconfig.json` file, that tells the compiler about the aliases that you want to add. Something like this:

[source,json,title="tsconfig.json"]
----
{
    "compilerOptions": {
        "baseUrl": "./src",
        "paths": {
            "@components/": ["./common/components/"],
            "@hooks/": ["./common/hooks/"],
            "@services/": ["./services/"],
            "@assets/": ["./assets/"],
            "@utils/": ["./utils/"]
        }
    }
}
----

== Create React App

If you used `create-react-app` to bootstrap your React application you won't be able to access the Webpack configuration directly. You can run `npm run eject` to take over the configuration files, but this would mean handling every aspect of the configuration yourself which overtime can be quite tedious. Luckily, there is a package called `craco` or _Create React App Configuration Override_ that we can use to hook into the underlying configuration and update it as needed.

IMPORTANT: Since this post was first written, the React team does not recommend using CRA anymore for new projects. Instead, opt to use a framework such as Next.js, Remix, or something else which also provides this functionality out of the box.

You can install this package with:

[source,console]
----
$ npm i -D @craco/craco
----

And you will also have to change the scripts section on the `package.json` file to use it, instead of the default react scripts.

[source,json,title="package.json"]
----
"scripts": {
    "start": "react-scripts start" // [!code --]
    "build": "react-scripts build" // [!code --]
    "test": "react-scripts test" // [!code --]
    "start": "craco start" // [!code ++]
    "build": "craco build" // [!code ++]
    "test": "craco test" // [!code ++]
}
----

Lastly, your changes should go to a new file named `craco.config.js`, specifically under the `webpack` property:

[source,javascript,title="craco.config.js"]
----
module.exports = {
    webpack: {
        alias: {
            '@components': path.resolve(__dirname, 'src/components'),
            '@hooks': path.resolve(__dirname, 'src/hooks'),
            '@services': path.resolve(__dirname, 'src/services'),
            '@assets': path.resolve(__dirname, 'src/assets'),
            '@utils': path.resolve(__dirname, 'src/utils'),
        },
    },
    plugins: {
        add: [],
        remove: [],
    },
    configure: (webpackConfig, { env, paths }) => {
        return webpackConfig;
    },
};
----

As you can see, there are plenty of other options. As always, https://craco.js.org/docs/[check out the documentation to know more].

=== craco-alias

CAUTION: The craco-alias package is now deprecated in favor of react-app-alias. It works very similarly, but please refer to the documentation page for details.

When using `craco` to manage the configuration of a CRA project, it will override the `tsconfig.json` file when the application runs. In order to work around this issue we create an additional file with the content that we want to update, and extend the main configuration file with it instead:

[source,json,title="tsconfig.extend.json"]
----
"compilerOptions": {
    "baseUrl": "./src",
    "paths": {
        "@components/": ["./common/components/"],
        "@hooks/": ["./common/hooks/"],
        "@services/": ["./services/"],
        "@assets/": ["./assets/"],
        "@utils/": ["./utils/"]
    }
}
----

[source,json,title="tsconfig.json"]
----
{
    "extends": "./tsconfig.extend.json", // [!code ++] # <1>
    "compilerOptions": { // [!code --]
        "baseUrl": "./src", // [!code --]
        "paths": { // [!code --]
            "@components/": ["./common/components/"], // [!code --]
            "@hooks/": ["./common/hooks/"], // [!code --]
            "@services/": ["./services/"], // [!code --]
            "@assets/": ["./assets/"], // [!code --]
            "@utils/": ["./utils/"] // [!code --]
        } // [!code --]
    } // [!code --]
}
----
<1> Extend the configuration instead of writing it directly.

Before things work we need to add another auxiliary package for `craco` and update the configuration:

[source, console]
----
$ npm i -D craco-alias
----

[source,javascript,title="craco.config.js"]
----
module.exports = {
    webpack: {
        alias: {
            '@components': path.resolve(__dirname, 'src/components'),
            '@hooks': path.resolve(__dirname, 'src/hooks'),
            '@services': path.resolve(__dirname, 'src/services'),
            '@assets': path.resolve(__dirname, 'src/assets'),
            '@utils': path.resolve(__dirname, 'src/utils'),
        },
    },
    plugins: [
        {
            plugin: CracoAlias,
            options: {
                source: "tsconfig",
                baseUrl: "./src",
                tsConfigPath: "./tsconfig.extend.json"
            }
        }
    ],
    configure: (webpackConfig, { env, paths }) => {
        return webpackConfig;
    },
};
----

== Vite.js

Since https://vitejs.dev[Vite.js] is one popular alternative to Webpack these days, I thought I should also mention it. The steps are almost the same: update the `tsconfig.json` file as described above (ignore if TypeScript is not in use) and then update its own configuration with the same details:

[source,typescript,title="vite.config.ts"]
----
import { defineConfig } from 'vite';

export default defineConfig({
    resolve: {
        alias: {
            '@assets': path.resolve(__dirname, 'src/assets'),
            '@components': path.resolve(__dirname, 'src/components'),
            '@features': path.resolve(__dirname, 'src/features'),
        },
    },
});
----
