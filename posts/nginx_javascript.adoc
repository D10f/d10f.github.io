= Modifying HTTP Responses On The Fly
D10f <devontheroof@pm.me>
v1, 2025-08-18
:license-url: https://creativecommons.org/licenses/by-sa/4.0/
:license-title: CC BY-SA 4.0
:doctype: article
:description: Nginx's JavaScript engine can be used to modify request & responses on the fly. Let's see how.
:keywords: docker, nginx, web, server, javascript
:technologies: nginx javascript
:source-highlighter: pygments
:icons: font
:toc:

The Nginx JavaScript engine, "njs", is available out of the box in most distributions as well as in the latest Docker image.

== Example 1: Setting Response Headers Dynamically

First, let me give you some context.

Recently, I've been working on making an HTTP client in Python. I used Nginx running inside a Docker container to make sure basic requests were working properly. At one point I needed to test if redirects and rate limiting responses were handled properly, both of which may include the header "Retry-After".

This header specifies the time that the client must wait before making another request to the server. How it does that precisely is defined in https://www.rfc-editor.org/rfc/rfc9110.html#name-date-time-formats[RFC9110], using what's called an "IMF-fixdate" format. However, this RFC also states that a client must accept another two now-obsolete formats, still considered for backwards compatibility.

Since these headers needed to specify dates into the future, I had to edit the configuration file inside the Docker container, reload the server, and run my script to make sure it waited to appropriate amount of time. Very tedious and time-consuming, and exactly where `njs` comes in to the rescue.

The goal is to find a sweet spot of just a few seconds into the future so that I could know for sure my HTTP client worked properly, without having to wait for too long, so that I could iterate through my code as I fixed any bugs.

=== Format The Date Strings

For every request there must be a Retry-After header returning a date string formatted in one of the accepted formats:

Sun, 06 Nov 1994 08:49:37 GMT :: A fixed-length and single-zone subset of the date and time specification used by the Internet Message Format in RFC5322.

Sunday, 06-Nov-94 08:49:37 GMT :: Format used in the now-obsolete RFC850.

Sun Nov  6 08:49:37 1994 :: An old format used by ANSI C's asctime() function.

Let's start by writing a few functions to handle this for the current date and time:

[source,javascript]
----
const imfDateRegExp = new RegExp(/^(?<weekday>\w{3}),\s+(?<day>\d\d)\s+(?<month>\w{3})\s(?<year>\d{4})\s(?<time>\S+) GMT$/);

const weekdays = {
    Mon: 'Monday',
    Tue: 'Tuesday',
    Wed: 'Wednesday',
    Thu: 'Thursday',
    Fri: 'Friday',
    Sat: 'Saturday',
    Sun: 'Sunday'
};

function getIMFDate() {
    return new Date(Date.now()).toUTCString();
}

function getRFC850Date() {
    const imf = getIMFDate();
    const match = imf.match(imfDateRegExp); // <1>

    const weekday = match.groups.weekday; // <2>
    const day = match.groups.day;
    const month = match.groups.month;
    const year = match.groups.year;
    const time = match.groups.time;

    return `${weekdays[weekday]}, ${day}-${month}-${year.slice(2)} ${time} GMT`;
}

function getAscTimeDate() {
    const imf = getIMFDate();
    const match = imf.match(imfDateRegExp);

    const weekday = match.groups.weekday;
    const day = match.groups.day;
    const month = match.groups.month;
    const year = match.groups.year;
    const time = match.groups.time;

    return `${weekday} ${month} ${day[0] == '0' ? ' ' + day[1] : day} ${time} ${year}`
}
----
<1> Since all date formats have the same components arranged in different ways, we can parse any and extract the components we need. In this case, the IMF format is the easiest to compute.
<2> Unfortunately, while `njs` has some convenient functionality like named capture groups, it does not yet support destructuring.

=== Computing The Date From Query Parameters

Next, we need to be able to specify which format we want to return, and how much of an offset add to it. Both of these things can be done by introducing a new function that reads the query parameters from the request:

[source,javascript]
----
function addRetryAfterHeader(r) { // <1>
    const format = r.args['format'];
    const amountInSeconds = r.args['amount'];
    const amountInMs = parseInt(amountInSeconds) * 1000;
    let formattedDate = '';

    switch (format) {
        case 'imf':
            formattedDate = getIMFDate(amountInMs);
            break;
        case 'rfc850':
            formattedDate = getRFC850Date(amountInMs);
            break;
        case 'asctime':
            formattedDate = getAscTimeDate(amountInMs);
            break;
        default:
            formattedDate = amountInSeconds; // <2>
    }

    r.headersOut['Retry-After'] = formattedDate;
}
----
<1> The "r" object, as it's commonly named in the Nginx documentation, represents the HTTP request.
<2> The Retry-After header can also be expressed as seconds. When the date format is not specified, we assume this is the case.

This is the function that will be invoked from Nginx. It will read the query string for the request and decide based on the "format" and "amount" values the correct return value. Except, there's really no return value since all we want to do is update the response headers. We can do that through the request object that gets passed automatically by Nginx, as seen at the bottom of the function.

=== Putting It All Together

And that's really it. Now it's a matter of wiring things up see if it works:

[source,nginx,title=/etc/nginx/conf.d/default.conf]
----
server {

    js_import /etc/nginx/njs/dates.js; # <1>

    location /my-endpoint {
        js_header_filter dates.addRetryAfterHeader;
        return 200 "Hello, world"; # <2>
    }
}
----
<1> Could omit the full path to the file by specifying the base directory inside the main configuration file using the `js_path` directive.
<2> Technically the Retry-After header is supposed to be used for 301 and 429 responses, but it will do for now.

[source,javascript,title=/etc/nginx/njs/dates.js]
----
const imfDateRegExp = new RegExp(/^(?<weekday>\w{3}),\s+(?<day>\d\d)\s+(?<month>\w{3})\s(?<year>\d{4})\s(?<time>\S+) GMT$/);

const weekdays = {
    Mon: 'Monday',
    Tue: 'Tuesday',
    Wed: 'Wednesday',
    Thu: 'Thursday',
    Fri: 'Friday',
    Sat: 'Saturday',
    Sun: 'Sunday'
};


/**
 * Adds the Retry-After response header, in a format and amount
 * specified by query parameters.
 *
 * @param   {NginxHTTPRequest} r    Request arguments object.
 */
function addRetryAfterHeader(r) {
    const format = r.args['format'];
    const amountInSeconds = r.args['amount'];
    const amountInMs = parseInt(amountInSeconds) * 1000;
    let formattedDate = '';

    switch (format) {
        case 'imf':
            formattedDate = getIMFDate(amountInMs);
            break;
        case 'rfc850':
            formattedDate = getRFC850Date(amountInMs);
            break;
        case 'asctime':
            formattedDate = getAscTimeDate(amountInMs);
            break;
        default:
            formattedDate = amountInSeconds;
    }

    r.headersOut['Retry-After'] = formattedDate;
}

/**
 * Returns a date in the format "Sun, 06 Nov 1994 08:49:37 GMT"
 *
 * @param   {Number} offset Amount of milliseconds to add to the current date.
 * @return  {String}        Date formatted string.
 */
function getIMFDate(offset) {
    return new Date(Date.now() + offset).toUTCString();
}

/**
 * Returns a date in the format "Sun, 06 Nov 1994 08:49:37 GMT"
 *
 * @param   {Number} offset Amount of milliseconds to add to the current date.
 * @return  {String}        Date formatted string.
 */
function getRFC850Date(offset) {
    const imf = getIMFDate(offset);
    const match = imf.match(imfDateRegExp);

    const weekday = match.groups.weekday;
    const day = match.groups.day;
    const month = match.groups.month;
    const year = match.groups.year;
    const time = match.groups.time;

    return `${weekdays[weekday]}, ${day}-${month}-${year.slice(2)} ${time} GMT`;
}

/**
 * Returns a date in the format "Sun Nov 6 08:49:37 1994"
 *
 * @param   {Number} offset Amount of milliseconds to add to the current date.
 * @return  {String}        Date formatted string.
 */
function getAscTimeDate(offset) {
    const imf = getIMFDate(offset);
    const match = imf.match(imfDateRegExp);

    const weekday = match.groups.weekday;
    const day = match.groups.day;
    const month = match.groups.month;
    const year = match.groups.year;
    const time = match.groups.time;

    return `${weekday} ${month} ${day[0] == '0' ? ' ' + day[1] : day} ${time} ${year}`
}

export default { addRetryAfterHeader };
----

== Example 2: Runtime Environment Variables

I know, I know. Full-stack frameworks like Next.js are all the rage these days. But there are still valid reasons to use plain React to build simple, interactive web applications.

One of the many caveats that these web apps have, however, is they require a build step before they're deployed. This makes things a bit more complicated than they need to be when there are changes unrelated to the business logic. This doesn't necessarily mean sensitive information, like API keys. It could be simple values that remain constant throughout the lifetime of the application, locale changes, poll intervals, etc.

Consider as an example a file upload component. As with all user input, the validation will happen on the server side, but we want to give the user a good experience and inform them about errors when the file size is exceeded, or the file types is invalid. None of these are crucial, sensitive information, but having it kept in sync with our server is important.

=== Deploying With Docker

In this example, we deploy the client and the server using a Docker Compose file, something like this (simplified for brevity):

[source,yaml,title=docker-compose.yml]
----
---
services:
    client:
        build:
            context: ./client
            args:
                - MAX_FILE_SIZE=1GB
                - UPLOAD_CHUNK_SIZE=64KB
                - POLL_INTERVAL=30

    server:
        build:
            context: ./server
        environment:
            MAX_FILE_SIZE: 1GB
            UPLOAD_CHUNK_SIZE: 64KB
----

When deployed, both our server and client applications know how large a file can be, and what size each chunk of the upload must be. The problem, however, is that our client application is built with those hard coded values, and any changes requires re-building and re-deploying it.

And that may seem fine since the server would also need to be re-deployed to keep these values in sync, but if we decided to change the poll interval, which doesn't affect the server, then we have to go through this again.

By the way, in this example the "client" is really just a Nginx image that serves the built artifacts from React.

=== Inject Environment Variables Dynamically

Using `njs` we can modify the request body to inject a piece of JavaScript code containing our global variables:

[source,nginx,title=/etc/nginx/conf.d/default.conf]
----
server {
    js_import /etc/nginx/njs/http.js;

    location / {
        js_body_filter http.injectEnvVariables;
        js_header_filter http.clearContentLength; # <1>
        try_files $uri $uri/ /index.html;
    }
}
----
<1> Since we're changing the length of the content, we need to delete Content-Length header to force it to be "chunked encoded".

[source,javascript,title=/etc/nginx/njs/http.js]
----
function injectEnvVariables(r, data, flags) {
    const newData = `
        <script>
            window.__ENV__ = {
                MAX_FILE_SIZE: '1GB'
                UPLOAD_CHUNK_SIZE: '64KB'
                POLL_INTERVAL: 30
            }
        </script>
    `;

    const response = data.replace(/(<head>)/, "$1" + newData);
    r.sendBuffer(response, flags);
    r.done(); # <1>
}

function clearContentLength(r) {
    delete r.headersOut['Content-Length'];
}

export default { injectEnvVariables, clearContentLength };
----
<1> This is `njs` saying we won't be filtering this content further.

This piece of code added will execute in the browser, creating an object that is globally available through the application:

[source,javascript,title=UploadService.js]
----
const UPLOAD_CHUNK_SIZE = parse(window__ENV__.UPLOAD_CHUNK_SIZE); # <1>

class UploadService {
    constructor(file) {
        this._totalChunks = Math.ceil(file.size / UPLOAD_CHUNK_SIZE);
    }
}
----
<1> The `parse` function transforms the 64KB string to the number 65536.

Since it's just plain JavaScript we can come in here and change this code at anytime without rebuilding entire application &mdash; a simple reloading of the Nginx process will do.

=== Cleaning Up Things A Little

This works, but we might be slightly annoyed at having to update our variables in two places (the JavaScript file as well as the Docker Compose file).

We could try with environment variables, either passed through a `.env` file or directly through Docker's options:

[source,yaml,title=docker-compose.yml]
----
---
services:
    client:
        build:
            context: ./client
        environment: # [!code ++]
            MAX_FILE_SIZE: 1GB # [!code ++]
            UPLOAD_CHUNK_SIZE: 64KB # [!code ++]
            POLL_INTERVAL: 30 # [!code ++]
        env_file: .env # [!code ++]

    server:
        build:
            context: ./server
        environment:
            MAX_FILE_SIZE: 1GB
            UPLOAD_CHUNK_SIZE: 64KB
----

However, the problem with this approach is that Nginx does not inherit the environment variables, and unfortunately none of these values would be available. Unless, that is, you also use the `env` directive in the main configuration file _for each_ environment variable_:

[source,nginx,title=/etc/nginx/nginx.conf]
----
user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log notice;
pid        /run/nginx.pid;

events {
    worker_connections  1024;
}

load_module /etc/nginx/modules/ngx_http_js_module.so;

env MAX_FILE_SIZE; # [!code highlight]
env UPLOAD_CHUNK_SIZE; # [!code highlight]
env POLL_INTERVAL; # [!code highlight]

http {
    # ...
}
----

This is not ideal if you have a ton of these variables, but it does mean that you can update their values in just one location. The main downside is that you have to remember to add them here as well.

Once you have these variables loaded inside Nginx, you can access them from `njs` through the `process.env` object:

[source,javascript,title=/etc/nginx/njs/http.js]
----
function injectEnvVariables(r, data, flags) {
    const __ENV__ = {}; // [!code ++]

    // [!code ++:3]
    for (const key in process.env) {
        env[key] = process.env[key];
    }

    const newData = `
        <script>
            // [!code --:5]
            window.__ENV__ = {
                MAX_FILE_SIZE: '1GB',
                UPLOAD_CHUNK_SIZE: '64KB',
                POLL_INTERVAL: 30,
            };
            // [!code ++:1]
            window.__ENV__ = ${JSON.stringify(__ENV__)} // <1>
        </script>
    `;

    const response = data.replace(/(<head>)/, "$1" + newData);
    r.sendBuffer(response, flags);
    r.done();
}
----
<1> We need to convert this object into a string. The client later will have to parse numerical values accordingly.

Since only the environment variables we specified in the Nginx configuration file are available, we can loop freely over the `process.env` object. We could also add a quick check to ensure only the variables that we're interested in are loaded. For example, is not uncommon to prefix them with `REACT_APP` or `VUE_APP`.
