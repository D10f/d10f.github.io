= Basic Access Control With Nginx
D10f <devontheroof@pm.me>
v2, 2021-05-15
:license-url: https://creativecommons.org/licenses/by-sa/4.0/
:license-title: CC BY-SA 4.0
:doctype: article
:description: Protect website routes behind a simple but effective authentication layer with Nginx.
:keywords: linux, nginx, web, server, authentication
:technologies: nginx
:source-highlighter: pygments
:icons: font
:toc:

Preamble

== Password-protected Routes

Nginx supports the https://www.rfc-editor.org/rfc/rfc7617.html[HTTP Basic Authentication scheme] through the use of the `auth_basic` and `auth_basic_user_file` directives. This authentication scheme is quite straight forward: a simple challenge-response, where the user sends the username and password that the client then validates against a password file stores on the server. For example:

[source,nginx]
----
location /dashboard {
  auth_basic "Admin Dashboard"; # <1>
  auth_basic_user_file /etc/apache2/.htpasswd; # <2>
}
----
<1> Identifier for the "realm" which can be used by the client to partition different protected resources.
<2> The password file containing the username-password pairs.

NOTE: RFC 7617, as well as the original RFC 2617, refer to the server implementing the Basic Access Authentication scheme as the "client", and visitors who need to pass the challenge-response as the "users". This post follows this terminology.

Upon visiting this route through a web browser, the user would be presented with a prompt asking for a username and a password, which would then be validated against the password file specified by the `auth_basic_user_file` directive. The password file contains a list of username-password pairs:

[source]
----
# This is a comment
username1:password1
username2:password2:also a comment
----

CAUTION: This authentication scheme sends the challenge-response from the client in clear text (base64-encoded). It SHOULD NOT be used without additional security enhancements such as HTTPS.

Due to the sensitive nature of this file, passwords stored in this file are expected to be hashed using one of the following hashing algorithms: MD5, APR1 (a variant of MD5 used by Apache), SHA256, SHA512 or Bcrypt (otherwise authentication will fail). There are two well-known utilities that can be used to generate passwords in this format:

=== htpasswd

The `htpasswd` command is part of the `apache2-utils` package for Debian distributions, or `http-tools` for Red Hat distributions.

You can provide the `-c` flag to create a new password file, followed by the username that you want to create a password for. This will ask for the password, which you'll have to confirm once:

[source,console]
----
$ htpasswd -c /etc/apache2/.htpasswd username1
----

[literal]
Output:
New password:
Re-type new password:
Adding password for user username1

WARNING: Be careful with the `-c` flag. If the file already exists, it will overwrite its contents. This may be what you want as a fresh start but err on the side of caution and use only when you see a file not found error.

If you prefer to disable the interactive prompt &mdash; for instance when working with scripts &mdash; you can use the `-b` or `-i` options. This will instruct `htpasswd` to read the password from the argument list or standard input, respectively.

Note that if the file already contains an entry for the given username, it will overwrite:

[source,console]
----
$ htpasswd -b /etc/apache2/.htpasswd username2 password2 # <1>
$ echo 'password2' | htpasswd -i /etc/apache2/.htpasswd username2 # <2>
----
<1> Create a new entry for _username2_ using the second argument as the password.
<2> Update the password for _username2_ using the value from standard input.

To work with different hashing algorithms you can provide the `-m`, `-2`, `-5` and `-B` options, to use the APR1, SHA256, SHA512 and Bcrypt algorithms, respectively &mdash; APR1 is the default.

[source,console]
----
$ htpasswd -c /etc/apache2/.htpasswd username1
$ htpasswd -bm /etc/apache2/.htpasswd username2 password2
$ htpasswd -b2 /etc/apache2/.htpasswd username3 password3
$ htpasswd -b5 /etc/apache2/.htpasswd username4 password4
$ htpasswd -bB /etc/apache2/.htpasswd username5 password5
$ cat /etc/apache2/.htpasswd
----

[literal]
Output:
username1:$apr1$ZLqohdtm$VBG8lhqD36qNcgYzOCwyu.
username2:$apr1$WAK/0l85$A2sse6WVWUqRqZxfejACk0
username3:$5$2gqVCGNKd79W2aAR$BNgoVt2zEstkv.NgYX/kNQBUgdNBaw6dFmOlLs4YQ78
username4:$6$/z2zCgqn5bS937bz$icXPUBe1CGhaR9Ljzp67dl/RkqrNtYWFRzfJ7Od72lrdBbHnMHiPq3.UYOVIN3ZQ4QY.zw/VrcP00Fm9yyERJ1
username5:$2y$05$gg43xXNMO3/GU8tE6Ur/SecayWXgVzrLm96ZiqThz91TSowKYcIf6

=== openssl

The `openssl passwd` command is used to compute password hashes. It takes in an input which is then hashed using the MD5 hashing algorithm by default. This behavior can be modified to use other algorithms to match the requirements of the file password as described above:

[source,console]
----
$ openssl passwd s3cr3P4$$w0rd # <1>
$ openssl passwd -apr1 s3cr3P4$$w0rd # <2>
$ openssl passwd -5 s3cr3P4$$w0rd # <3>
$ openssl passwd -6 s3cr3P4$$w0rd # <4>
----
<1> Hash computed using the MD5 algortihm.
<2> Hash computed using the APR1 algortihm.
<3> Hash computed using the SHA256 algortihm.
<4> Hash computed using the SHA512 algortihm.

Instead of providing the password as an argument you can use the `-in` option to specify a file, or the `-stdin` to read from standard input. This can be helpful to decrease the risk of leakage due to passwords appearing in the shell's history to in a process monitor.

Unlike `htpasswd`, it won't create a new file for storing the username and password pair, nor it will append to it. It simply outputs the computed hash of the given password, and is up to you to update the file however you choose to. It may be more convenient to use `htpasswd` instead of `openssl` because of this, but it may also not be possible to install new software on certain environments, whereas OpenSSL is a popular library likely to be included in that case.

== Restrict Access Based On The IP Address

Using the IP address of the source request is another useful way of restricting access. While there are better ways to implement automated filters to prevent spam and other suspicious activities, this approach has the advantage of being more granular as it allows for more complex rules. For example, a private reporting tool that only computers in the internal network should be allowed to access. Applications deployed as containers may also benefit from this as their IP addresses can be managed accordingly.

To get started, use the `deny` and `allow` directives:

[source,nginx]
----
location /dashboard {
    deny 192.168.1.40;
}
----

We can also specify ranges of IP addresses:

[source,nginx]
----
location /dashboard {
    deny 192.168.1.1/24;
}
----

But this gets more interesting when stacking multiple directives to create complex rules:

[source,nginx]
----
location /dashboard {
    allow 192.168.1.40;
    deny 192.168.1.1/24;
}
----

This rule doesn't allow access to any IP on that range, with one exception. Rules are resolved from top to bottom, and Nginx stops checking once there is a match; if we put the `deny` directive first it wouldn't allow that one IP address as it's part of the specified range which explicitly denies it.

Either of these directives can also accept a catch-all value, promptly called "all", pretty useful to narrow the scope of a route:

[source,nginx]
----
location /dashboard {
    allow 192.168.1.40;
    deny 192.168.1.1/24;
    allow 10.20.30.1/24;
    deny all;
}
----

=== Forward Original IP Address

When acting as a reverse proxy, Nginx opens a new network request using the IP address of the host where it runs on, instead of forwarding the original IP from the client. To...

== Restrict Access Based On The Result Of A Sub-request

https://nginx.org/en/docs/http/ngx_http_auth_request_module.html
