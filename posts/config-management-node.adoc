= Configuration Management With Node.js
D10f <devontheroof@pm.me>
v2, 2022-09-10
:license-url: https://creativecommons.org/licenses/by-sa/4.0/
:license-title: CC BY-SA 4.0
:doctype: article
:description: Handle configuration of your application through environment variables, including validation and enforcing a schema.
:keywords: nodejs typescript configuration server application deployment
:technologies: nodejs typescript docker
:source-highlighter: pygments
:icons: font
:toc:

Configuration and code should live in strict isolation from each other. Everything that is likely to change between deployments, is configuration: database credentials, API keys, hostnames, and even global constants used in code. This model scales up smoothly as the app naturally expands in size and complexity, and by extension, the number of environments it will be deployed on.

== Environment Variables

In Node.js, the global object `process.env` contains information related to the execution environment; the properties found in it, are environment variables. They may contain information such as the username who owns the process, the current location of the entry point, etc. However, we can add our own variables to this in order to customize the behavior of our application. For example, we could specify the size limit of file upload:

[source,console]
----
$ export MAX_FILE_SIZE=1024
$ nodemon src/index.js
----

To make a variable available to the Node.js process we declare it at the command line, using the `export` keyword; this would make the variable last throughout the shell session. We can also declare them at the same time as we run some process, and they would exist for that particular process but cease to exist immediately otherwise. This is sometimes used within `package.json` files, in the scripts section:

[source,json,title="package.json"]
----
{
    "scripts": {
        "dev": "MAX_FILE_SIZE=1024 nodemon src/index.js"
    }
}
----

However, a far more common approach for providing environment variables to our application is through an external file (typically called `.env`). This it far more portable between developers and environments, including deployments, and much easier to maintain over time.

[source,javascript,title=".env"]
----
MAX_FILE_SIZE=1024 # <1>
----
<1> Write each environment variable in its own line, without spaces.

For a very long time, a popular package called `dotenv` has been used to read from this file automatically when the application starts. This saves us time in writing boilerplate logic about it:

[source,javascript]
----
import * as dotenv from 'dotenv';
dotenv.config();

console.log(process.env.MAX_FILE_SIZE);
----

This is such a common pattern that, as of Node.js 20.6 there is experimental support to do this natively:

[source,javascript,title="index.js"]
----
console.log(process.env.MAX_FILE_SIZE);
----

[source,console]
----
$ node --env-file=.env index.js # <1>
----
<1> Start the application passing the `--env-file` flag pointing to the file in question.

== Schema Validation

Environment variables can be considered a form of user input and as such, we want to validate them. This can help to catch errors early and use sane defaults when certain variables are not provided. In addition, one important property of environment variables is that they are always strings and may need to be explicitly cast into their correct type when used inside our application.

There are quite a few packages that can be used for this, but https://zod.dev/[zod] is one that has gained a lot of traction in the past few years.

NOTE: I will give a shout out to joi as an honorable mention as well. Is still in active development, but I haven't used it in quite a while as I found it lacking in some areas regarding TypeScript support (this may have changed since last time I checked it out).

We can create a file that will contain our schema definition, describing the properties that should exist in our application and constraints about them. For example, it wouldn't make sense to have a negative value as the maximum file size to upload (unless for some reason you decide that signifies something special).

[source,typescript,title="schema.ts"]
----
import { z } from 'zod';

export const schema = z.object({
    MAX_FILE_SIZE: z.string().default('1024').transform(value => parseInt(value)) # <1>
});

export type SchemaIn = z.input<typeof schema>; # <2>
export type SchemaOut = z.output<typeof schema>; # <3>
----
<1> We validate that the property exists and is a string, and has a default value of '1024' if is not specified. We also transform it using a function to cast it into a number.
<2> The type of the schema object before the values are transformed.
<3> The type of the resulting schema object after transformation. This is what our application should use.

This library is quite handy for two reasons: 1) it allows us to infer the types very easily 2) we can use both the type of the object before and after it's processed. We can take advantage of the latter to validate the properties from the environment as they were provided in order to detect errors, as we mentioned.

=== Create A Configuration Service Class

To keep things organized we can create a service to encapsulate all the logic pertaining to validating and, later, accessing the configuration throughout our application.

[source,typescript,title="ConfigService.ts"]
----
import * as dotenv from 'dotenv';
import { SchemaIn, SchemaOut } from './schema';

export default class ConfigService {

    private readonly config: SchemaOut; # <1>

    constructor(schema: SchemaIn) { # <2>
        this.readEnv();
        this.config = this.validate();
    }

    private readEnv() {
        dotenv.config(); # <3>
    }

    private validate() {
        const { value, error } = this.schema.validate(process.env); # <4>

        if (error) {
            error.details.forEach(err => console.error((err as Error).message));
            throw new Error('Errors found during validation');
        }

        return value;
    }

    get<T extends keyof SchemaOut>(key: T) {
        return this.config[key];
    }
}
----
<1> The final configuration for our application, validated and transformed into the appropriate values and types.
<2> Receive the schema object generated by the zod library.
<3> Read environment variables, somehow. This will be more important in a bit.
<4> Here we validate the whole object with our environment variables. Most libraries will prune everything that is not part of the schema.

We can now use our configuration class to access the validated environment variables, enjoying the full benefit of type inference and autocompletion in our code:

[source,typescript,title="index.ts"]
----
import ConfigService from './ConfigServce';
import { schema } from './schema';

const config = new ConfigService(schema);

console.log(config.get('MAX_FILE_SIZE'));
----

IMPORTANT: There are many improvements we can make to this class. For example, it's going to be used throughout our entire codebase, so it would be better to design it as a singleton, or implement some form of caching, so that we don't validate the same object over and over again at runtime.

== Handling Sensitive Information

Quite often, environment variables deal with sensitive information that you wouldn't necessarily want to expose to the public. This is why `.env` files are ignored by version control systems by default. It makes it more difficult to deploy applications without exposing those secrets; indeed, one of the biggest challenges regarding security is dealing with keys and secrets securely.

This is where Secret Management services come in, such as Vault by Hashicorp. However, to keep things simple I'll use as an example a much more rudimentary and often overlooked technology that handles this aspect of environment variables quite nicely: Docker Swarm.

=== Docker Swarm Secrets

Docker Secrets is a feature that allows a Docker Swarm Manager node to hold sensitive information encrypted at rest, and pass it to any running services that need it. There are many container images that accept environment variables in form of a _string_ or a _path to a file_, by using a "_FILE" suffix. This makes it very convenient to use the same compose file for production and still commit it to version control without exposing any sensitive information.

Here's an example of how that would look like, using our `MAX_FILE_SIZE` variable we've seen thus far, along with a Mongo database also reading values from the environment in the form of secrets:

[source,yaml,title="docker-compose.yml"]
----
version: '3.8'

services:

  app:
    image: node:20
    secrets:
      - max_file_size
    environment:
      - MAX_FILE_SIZE_FILE: /run/secrets/max_file_size

  mongo:
    image: mongo
    secrets:
      - mongodb_name
      - mongodb_user
      - mongodb_password
    environment:
      MONGO_INITDB_DATABASE_FILE: /run/secrets/mongodb_name
      MONGO_INITDB_ROOT_USERNAME_FILE: /run/secrets/mongodb_user
      MONGO_INITDB_ROOT_PASSWORD_FILE: /run/secrets/mongodb_password

secrets:
  mongodb_name:
    external: true
  mongodb_user:
    external: true
  mongodb_password:
    external: true
  max_file_size:
    external: true
----

NOTE: You could also suffix your variables like this inside your .env file, but with Docker Swarm in particular this would probably be the most common way to do it.

Based on this compose file we don't know what the secrets are, but we know they are made available and exist only within this container instance. We can now update our configuration service class to read from these locations

[source,typescript,title="ConfigService.ts"]
----
import * as dotenv from 'dotenv';
import { SchemaIn, SchemaOut } from './schema';

export default class ConfigService {

    private readonly config: SchemaOut;

    constructor(schema: SchemaIn) {
        this.readEnv();
        this.config = this.validate();
    }

    private readEnv() {
        dotenv.config();
        this.readSecrets(); // [!code ++]
    }

    private readSecrets() { // [!code ++]
        for (const [ key, value ] in Object.entries(process.env)) { // [!code ++]
            if (! key.endsWith('_FILE')) continue; // [!code ++] # <1>

            try { // [!code ++]
                process.env[key] = fs // [!code ++]
                    .readFileSync(value, { encoding: 'utf-8' }) // [!code ++]
                    .replace('\n', '');  // [!code ++] # <2>
            } catch(err) { // [!code ++]
                throw new Error(`File not found for key ${key}.`); // [!code ++] # <3>
            } // [!code ++]
        } // [!code ++]
    } // [!code ++]

    private validate() {
        const { value, error } = this.schema.validate(process.env);

        if (error) {
            error.details.forEach(err => console.error((err as Error).message));
            throw new Error('Errors found during validation');
        }

        return value;
    }

    get<T extends keyof SchemaOut>(key: T) {
        return this.config[key];
    }
}
----
<1> Ignore variables that do not end with "_FILE".
<2> Remove newline character added by Node's `readFileSync`.
<3> You could choose to be a little more loose with this and use a default value. Although, this would be a good way to detect errors with deployment setups as well.

Since this happens _before_ the schema validation all environment variables are processed in the right order. Mind you, this process would work all the same even when not deploying through Docker, but we have made our application more resilient to changes in the environment in which it is deployed.

And that's it! From this point on is just a matter of playing with the schema and use this class everywhere you need an environment variable in your code. There are a number of improvements that this class needs to be production-ready, but this should handle most cases just fine.
