= Modern Image Formats For The Modern Web
D10f <devontheroof@pm.me>
v1, 2025-09-11
:license-url: https://creativecommons.org/licenses/by-sa/4.0/
:license-title: CC BY-SA 4.0
:doctype: article
:description: How to load images efficiently
:keywords: html css javascript images performance
:technologies: html css javascript shell
:source-highlighter: pygments
:icons: font
:toc:

Images are at the core of the web. We see them everywhere, from social media to blogs, to forums to private [.line-through]+WhatsApp+ Signal groups. And yet, there are still plenty of websites that are oblivious to modern standard formats like WebP or AVIF, and not only they don't use it, but don't even support it when uploading profile pictures, etc.

== Image Formats

WebP :: ...

AVIF :: ...

JPEG XL :: The JPEG XL format comes from the creators of the original JPEG, the good ol' trusty image format that remains the most widely used to this day. Despite a few failed attempts at bringing JPEG up to modern standards, this new format emerges as a real contender to the race. +
 +
However, as of this writing, support is very limited among web browsers. Safari is the only one that has implemented support, and Google ditched it after trying it out for a while in Chrome Canary version. Mozilla has announced plans to support it in upcoming versions.

== Loading Techniques

=== Lazy Loading

Since the introduction of lazy loading images as a native feature in browsers, this has been a no-brainer for some time. It's very simple to enable, too:

IMPORTANT: Lazy loading images only works when JavaScript is enabled.

[source,html]
----
<img loading="lazy" src="whatever.png" />
----

=== Responsive Images

While loading images can be done with a simple `<img>` element that gets loaded. But not all devices are created equal; some are large 4K displays than can fit larger images, while others are smartphones with limited screen real state. We can be specific about which image file to deliver to each visitor based on their device.

The `picture` element can be used to achieve this:

[source,html]
----
<picture>
    <source type="image/avif" srcset="pic01.jxl">
    <source type="image/avif" srcset="pic01.avif">
    <source type="image/webp" srcset="pic01.webp">
    <img
        srcset="
            https://placehold.co/800x200/jpg   800w,
            https://placehold.co/1600x400/jpg 1600w,
            https://placehold.co/3200x800/jpg 3200w
        "
        sizes="(max-width: 600px) 100vw, 1000px"
    >
</picture>
----

The browser will read this from top to bottom, and choose the first format that it can support. The `img` element at the bottom will act as a fallback, and here's where I'm specifying the most widely used format that will work on all browsers.

Being responsive also means using the best image format. As mentioned earlier, different formats are more efficient than others. But, again, not all browsers are created equal, and we want to be able to deliver the best format to each visitor.

=== Progressive Loading

...

Another way to create this effect of progressive loading is by using a heavily resized and blurred version of original image, so that it's very small and loads quickly, and use that as the background for that element. This will give a very clear hint that something ressembling the image is there, and will be loaded eventually, improving the user experience.

To do this, we'll have to play with HTML, CSS and JavaScript:

[source,html]
----
<div
    class="blurred-preview"
    style="background-image: url(pic01-blurred.jpg)" # <1>
>
    <img src="pic01.jpg" />
</div>
----
<1> You can choose to apply an inline style for each image to use a downsized version of the original, or use a generic placeholder.

Wrap the image into a container that imposes another image "on top", so that we can control the visibility of the final image while it loads.

TIP: Since CSS nesting is now supported, we can write it so that it's easier to read.

[source,css]
----
.blurred-preview {
    /* background-image: url(placeholder.jpg); */ # <1>
    background-size: cover; # <2>
    background-position: center; # <3>

    & img {
        opacity: 0; # <4>
    }
}

.blurred-preview--loaded {
    background-image: unset;
    background-size: unset;
    background-position: unset;

    & img {
        opacity: 1; # <5>
    }
}
----
<1> If you wanted to use a generic placeholder, this is where you'd specify it instead of in the HTML element.
<2> Since the image is going to be very small we want to expand it to _cover_ the entire element.
<3> Center it for consistency, although it'll be blurred enough that it won't make a huge difference.
<4> Make the image element invisible until it's loaded.
<5> Revert the opacity effect

Finally, we want to reverse the opacity on the image element once it's loaded. For that, we'll use an event listener from JavaScript:

[source,javascript]
----
const images = document.querySelectorAll('.blurred-preview img');

function removeBlurredPreview(img) {
    img.parent.classList.remove('blurred-preview--loaded');
}

images.forEach((img) => {
    if (img.loaded) {
        removeBlurredPreview(img);
    } else {
        img.addEventListener('load', () => removeBlurredPreview(img), { once: true });
    }
});
----

