= TypeScript Optional Generic Types
D10f <devontheroof@pm.me>
v1, 2025-11-07
:license-url: https://creativecommons.org/licenses/by-sa/4.0/
:license-title: CC BY-SA 4.0
:doctype: article
:description: declare generic functions that accept generic object types, then make them optional based on whether they have required (non-default) values.
:keywords: typescript types generics
:technologies: typescript
:source-highlighter: pygments
:icons: font
:toc:

Let's take a look at an example of how to harness the power of TypeScript's generic type system to create configurable factory functions.

== Motivation

The goal is to write a factory function to create some kind of object, providing a configuration object to define more precisely how that object will behave. In this particular case, I'm creating a Shiki transformer.

NOTE: If you are not familiar with Shiki, that's all right as this isn't a topic specific to it anyway. I'm just going to call it "the product" of the factory function.

Our starting point will be this naive type definition:

[source,typescript]
----
type ShikiTransformerFactory<T extends object> =
    (options: T) => ShikiTransformer;
----

And this will actually work just fine for most use cases. However, what lead me to write about this is a particular case where all the options have default values, and thus are completely optional:

[source,typescript]
----
type OptionsA = {
    name?: string;
    description?: string;
};

type OptionsB = {
    name: string;
    description?: string;
};

const transformerA: ShikiTransformerFactory<OptionsA> =
    (options) => {
        const name = options.name ?? "defaultName"; // <1>
        const description = options.description ?? "default Description"
        return {
            line() { /* ... */ }
        };
    };

const transformerB: ShikiTransformerFactory<OptionsB> =
    (options) => {
        return {
            preprocess() { /* ... */ },
            line() { /* ... */ },
        };
    };
----
<1> As `name` is optional in `OptionsA`, I use a default value.

Here we have two factory functions that create a transformer, each accepting a configuration object of type `OptionsA` and `OptionsB`, respectively. For simplicity, and to better illustrate what's happening, their properties are named the same.

We can try to use them like so:

[source,typescript]
----
const output = highlighter.codeToHtml(input, {
    theme: 'everforest-light',
    lang: 'typescript',
    transformers: [
        transformerA() // [!code error]
        transformerB({ name: 'B' })
    ]
});
----

A code editor would throw an error at this code; can you tell what's wrong here based on this snippet?

TypeScript is yelling at me because, according to the `ShikiTransformerFactory` definition, `transformerA` is expecting an argument, but none is provided. Which makes sense, sure. But looking again at `OptionsA` I only see optional properties. Does that mean that I _have_ to provide an object even when I don't intend to change the default values?

[source,typescript]
----
const output = highlighter.codeToHtml(input, {
    theme: 'everforest-light',
    lang: 'typescript',
    transformers: [
        transformerA() // [!code --]
        transformerA({}) // [!code ++]
        transformerB({ name: 'B' })
    ]
});
----

That is just... ugly &mdash; definitely not what I want. What can we do about this?

== Figuring Out If An Object Has Optional Properties

The problem to solve is to answer whether an object has any properties that are optional. If we can define this, we can create a better type definition for our factory function such that the options object is not required.

=== Is Property K In Object T Optional?

First, we need to find a way to determine if a single property K of an object T is optional. We can define a utility type for that:

[source,typescript]
----
type IsOptional<T, K extends keyof T> = undefined extends T[K]
    ? (object extends Pick<T, K> ? true : false)
    : false;
----

A property that is not declared with the optional parameter will evaluate to false here, as it's clearly not optional. The additional assertion in the _truthy_ portion of this ternary operator stems from the fact that a property might be declared as being of type `undefined` but still required.

NOTE: I must credit Chris Cook and his https://zirkelc.dev/posts/typescript-how-to-check-for-optional-properties[excellent blog post] on this very topic. The details on how this utility type works are explained in more detail there. I've adapted his examples slightly and expanded them to solve my use case.

We're only interested in properties that are strictly optional &mdash; those that are declared using the optional parameter `?` &mdash; so that we can ask the question using this new type:

[source,typescript]
----
type T1 = IsOptional<OptionsA, 'name'>;
//   ^? type T1 = true
type T2 = IsOptional<OptionsB, 'name'>;
//   ^? type T2 = false
----

=== Subset Of T Containing Optional-Only Properties

Since we won't know in advance the names of the properties to check if they're optional or not, we need to approach this in a more dynamic way. We can do just that by using mapped types, which will allow us to "iterate" over an object's keys one at the time. It looks something like this:

[source,typescript]
----
type OnlyOptional<T> = {
    [K in keyof T]: T[K];
}
----

This will make a copy of `T`. However, we can take things further by remapping each key `K` to another type. The trick here is that casting any key to `never` will effectively filter it out of the resulting type. And since our previous utility type evaluates to either true or false, we can use a ternary operator to do just that:

[source,typescript]
----
type OnlyOptional<T> = {
    [K in keyof T as IsOptional<T, K> extends true ? K : never]: T[K];
}

type T3 = OnlyOptional<OptionsB>;
//   ^? type T3 = { description?: string | undefined }
----

With this, we can now create new types that are based on other object types, filtering out optional properties. But how do we determine if at least one of the original keys in `T` is optional?

=== Asserting The Existence Of Optional Keys

Almost there! The last piece of the puzzle is to assert whether the resulting type from `OnlyRequired<T>` contains any keys at all, as only those that are required would be left out. As it turns out, the `keyof` operator will return `never` when an object type has no keys:

[source,typescript]
----
type isEmpty = keyof {};
//   ^? type isEmpty = never

type isEmpty = keyof { a: string };
//   ^? type isEmpty = "a"
----

So, let's create yet another utility type that evaluates this condition using, you guessed it, another ternary operator:

[source,typescript]
----
type HasOptionalKeys<T extends object> = keyof OptionalOnly<T> extends never ? false : true;
----

== Putting It All Together

All right, we have the ability to tell if a generic object type has optional properties or not. Back to our factory function, we can use this to branch out based on this:

[source,typescript]
----
type ShikiTransformerFactory<T extends object> =
    HasOptionalKeys<T> extends true
        ? (options?: T) => ShikiTransformer
        : (options: T) => ShikiTransformer;
----

Now, if the configuration object has any optional keys then it can be omitted entirely when it's invoked. This makes things just a tiny little bit nicer to work with, and helps to avoid unnecessary confusion.
