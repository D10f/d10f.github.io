= Debian Minimal Installation
D10f <devontheroof@pm.me>
v1, 2024-10-13
:license-url: https://creativecommons.org/licenses/by-sa/4.0/
:license-title: CC BY-SA 4.0
:doctype: article
:description:
:keywords: linux debian xorg dwm
:technologies: debian shell linux
:source-highlighter: pygments
:icons: font
:toc:

I like the idea of a "minimal" Linux desktop because that means there are fewer things to understand, and the more effective I can be with it. However, I don't like being dogmatic about things. Minimalism can become a very deep rabbit hole, and at the end of the day I need to be productive with my system. With that in mind, I'll be making certain trade-offs in the name of convenience as I see fit for my personal use case.

The goal of this exercise is to explore the different components that make up a Linux desktop and integrate them separately.

== Graphical Environment

After a bare installation of Debian we'll be greeted by a login prompt at the console; no graphical environment yet. This is where you'll need to log in as the root user, instead of your own non-privileged account, to install a few packages.

=== Xorg

The Xorg display server handles the display of graphical applications, as well as user events like mouse movement and keystrokes.

[source,console]
----
# apt install xorg
----

IMPORTANT: Xorg is an implementation of the X11 window system, which serves as a display server for Unix-like operating systems, including Linux.

This is a meta-package, that is, it links to other packages (that may also be meta-packages of their own) in order to facilitate the installation of the entire suite of software programs that make Xorg work properly. However, we can be a little more specific about what it is that we want to install:

[source,console]
----
# apt install \
    xinit \
    xkb-data \
    x11-xkb-utils \
    xserver-xorg-video-all \
    keyboard-configuration
----

We're not saving a lot of space by doing this, only about 30 Mb, but at least we have a better understanding of what's going on under the hood. We can now also install the remaining packages if we wish, depending on what we expect to do with our system:

[source,console]
----
# apt install \
    x11-utils \
    x11-xserver-utils \
    x11-session-utils \
    xfonts-utils \
    xinput
----

=== Mesa Drivers

Speaking of graphical applications, these days most applications will want to use the GPU to do things like hardware acceleration. To make the best out of the hardware, you can install the following package as well:

[source,console]
----
# apt install mesa-utils
----

This provides an assortment of open source implementations of industry-standard graphics programming API for things like 3D graphics, hardware acceleration, video processing, etc. So, not technically required, but it's a good idea to have it in there just in case.

== Firmware

Depending on your hardware, you might need additional drivers to make the best out of it. This may apply to all types of peripherals, not just graphics cards, like network adapters, audio devices, webcams, etc.

IMPORTANT: The term "free" in this context means that the source code is licensed under an open source license. This allows to examine and modify the code publicly, as opposed to be kept a secret (proprietary).

There free and non-free versions available. You can choose which version you want to use during the installation of Debian, and I'd recommend using the non-free as much as possible. However, if you notice that your computer doesn't work properly in terms of hardware compatibility or performance, it might be a good idea to install the non-free version as well:

[source,console]
----
# apt install firmware-linux-nonfree
----

== Suckless Utilities

Since the goal is to have something minimal, the https://suckless.org[Suckless project] seems like a good place to browse for minimally crafted software. The tools created by this project are _very_ minimal, offering nothing but the core functionality in order to offer something simple and lean. So minimal, in fact, that configuring these tools is done by editing the source code of the program directly, although this sounds a lot worse than it is.

Another nuance about this project is that any additional features are provided through "patches" contributed by the community, and these can be tricky to apply, so it's best to pick and choose only the ones that are really necessary &mdash; staying true to the philosophy of a minimalist setup!

Let's start by installing a few dependencies that we'll need.

[source,console]
----
# apt install libx11-dev libxinerama-dev libxft-dev git build-essential
----

Then, you can download the repository and build its source code with the following commands:

TIP: Use `pushd` and `popd` to quickly change in and out of directories. Unlike `cd -`, which only remembers the previous location, running `popd` will get you back to the initial location where you were at the time of running `pushd`. This is helpful when a command needs to be run from within a particular directory.

[source,console]
----
# git clone https://git.suckless.org/dwm /usr/local/src/dwm // <1> <2>
# pushd /usr/local/src/dwm ; make ; make clean install; popd
----
<1> Change "dwm" from these commands with whatever program you want to download.
<2> You can also change the location where is downloaded. I like to keep programs I compile in `/usr/local/src`. Make sure that location exists already.

=== Patching

When talking about the Suckless utilities it's important to understand that there's no configuration options other than actually editing the source code. Some of the most easily accessible settings are easily editable, but adding new features is only possible through community contributions available as so-called "patches".

These patches are git diff files that specify that modify the original source code directly at specific lines, and in specific ways. To apply a patch, you would need to download it first and then run the command, from the same directory where the source we're patching is located:

[source,console]
----
# patch -p1 < path/to/patch.diff
----

IMPORTANT: I tend to keep a folder named "patches" inside the source code for each program, to help me stay organized.

Since these files work under the assumption that the original source code has not been modified, it's going to become more likely that this command will result in an error, due to the patch file expecting to find certain lines of code that aren't in the now-modified source code.

I will leave a link to a video that talks about this in more detail, including how to deal with these type of merge conflicts when they happen. But in any case, remember: less is more!

https://www.youtube.com/watch?v=qIEUBvGvvRg[Patching dwm and suckless utilities - a friendly guide to patch and diff]

=== dwm

The Dynamic Window Manager is a simple tiling window manager. It provides the basic features that one would expect from such a program: automatic resizing of windows to make an efficient use of the screen, multiple layouts available, etc., and it will be our graphical environment, _in lieu_ of a fully-fledged desktop environment.

I'll also apply the following patches:

dwm-alwayscenter-20200625-f04cac6.diff :: Makes floating windows appear centered to the screen.

dwm-fullgaps-6.4.diff :: Adds a gap between the edge of the screen and any tiled windows, as well as between them.

dwm-movestack-20211115-a786211.diff :: Enables keyboard shortcuts to move windows in the stack, similar to how other window managers do this, like `i3`.

dwm-barpadding-20211020-a786211.diff (2021-10-20) :: So that we can add some gaps also between the top bar and the edges of the screen.

dwm-notitle-6.5.diff :: I don't like the title of the focused window to show up, since it tends to be quite large in browsers.

dwm-status2d-20200508-60bb3df.diff :: Allows special color codes to be used in the status bar.

=== dmenu

The Dynamic Menu, another simple utility that serves as an application launcher.

It reads newline-separated items from standard input, and returns whatever the user has selected to standard output. This can be leveraged in custom shell scripts to have some interactivity, as well, which is really useful.

The following patches are applied:

dmenu-center-20250407-b1e217b.diff :: Instead of showing the menu at the top, it shows it centered to the screen.

dmenu-border-20230512-0fe460d :: Draws a border around the window to help it to stand out more. Works great with the previous patch.

dmenu-fuzzymatch-5.3.diff :: Matches words using non-consecutive portions of the items. Very useful to avoid typos and make search quicker.

dmenu-caseinsensitive-20200523-db6093f.diff :: Changes the default behavior when matching items to be case-insensitive.

dmenu-desktoponly-20240811-475d809.diff :: Provides a new function to search only for application launchers, as opposed to any executable file in the user's `PATH`. This new function should be invoked by `dwm`, which needs to be adjusted in its configuration file.

There's one small caveat with the last patch: it doesn't fully conform to the https://specifications.freedesktop.org/basedir-spec/0.8/[XDG Base Directory Specification], as it ignores one critical location used by individual users. Luckily, it only requires changing one line of code from the launcher script, after applying the patch, on line 8:

[source,shell,title=/usr/local/src/dmenu/dmenu_path_desktop]
----
dirs="" # [!code --]
dirs="${XDG_DATA_HOME:-${HOME}/.local/share}/applications" # [!code ++]
----

This ensures that any custom desktop files that are placed in `XDG_DATA_HOME` will be picked up by `dmenu` as well.

=== st

The Simple Terminal is exactly that. Simple, but powerful and effective:

st-scrollback-ringbuffer-0.9.2.diff :: 

st-scrollback-mouse-altscreen-20220127-2c5edf2.diff :: These two patches enable terminal scrolling, which is otherwise disabled by default. More specifically, the second patch allows scrolling back using the mouse.

st-anysize-20220718-baa9357.diff :: This patch allows `st` to resize itself using pixels rather than character size, to avoid uneven gaps between windows.

=== slstatus

The status bar monitor. We can use this similar to a taskbar in some desktop environments, although this unfortunately doesn't have any interactivity. In that regard, I prefer something different like _dwmblock_ or _polybar_. But this one has the advantage of being quite straight forward to set up.

Only one patch is needed for this one:

slstatus-signals-1.0.patch :: This patch allows for each component of the status line to refresh on a separate interval, or when a predefined signal is sent to it.

=== slock

The Simple Lock, as simple as any system utility can get. Use it to lock your computer when you're away from it. With the following patches:

slock-background-image-20220318-1c5a538.diff :: Instead of displaying a full screen of a solid color, it shows background image.
slock-dpms-1.4.diff :: Automatically turns off the display if the session is not unlocked within a period of time.

== Login Startup Scripts


When I log in to my account, I'm used to seeing desktop icons, a background image, a taskbar loading, etc. But with this setup we only have a console environment that can't even launch graphical applications such us Firefox, GIMP or even a window manager like dwm; we'll see an error saying "cannot open display".

This is because we need to have an X display server up and running in order to launch graphical applications. On a typical installation there's another piece of software we haven't looked up yet, the "display manager", that handles all of this when we log in.

WARNING: This is a surprisingly complex topic. Depending on how we login there are a different set of scripts that get executed, and in seemingly different order. So, to keep this post as minimal as possible, I'm going to stick with the simplex option which is to manually run `startx`.

For now, let's see how we can do this manually ourselves. It's really simple, just run the `startx` command. This will initialize the X display server and also check a few file locations for commands to execute, one of the most known ones being a `~/.xinitrc` in our home directory. If we create this file in our home directory, we can specify which commands to run:

[source,shell,title=~/.xinitrc]
----
slstatus & # <1>
exec dwm # <2>
----
<1> Programs need to run in the background to avoid blocking the execution of this script
<2> The `exec` command here ensures that when the X server stops running we're also logged out of our accounts.

This is as minimal as it gets in this regard, basically going "full commando" on the login startup sequence. But, it helps with keeping things minimal!

== Session Management & Power Options

Now that we can log in to our account, we need a way to log out of it. In fact, we need a few other things to put our computer in sleep mode, reboot, power off, lock the screen, etc. All these niceties are readily available in most desktop environments through the start menu button, or something similar. We'll have to "settle" with running a command in the terminal. But we can make our own menu through `dmenu` as we'll see shortly.

=== Log Out

Logging out means to shut down all processes running by a particular user in the system. We can easily do this by running one command:

[source,console]
----
$ pkill -u $USER
----

=== Suspend, Reboot & Power Off

On Debian, we can leverage `systemd` to do all of these:

[source,console]
----
$ systemctl suspend
$ systemctl reboot
$ systemctl poweroff
----

For distributions using a different init system, such as Devuan, Artix, Alpine or GNU Guix, you could still install `pm-utils` to do the same thing.

=== Lock Screen

Earlier we installed `slock` to do this, with a patch to display a background image instead of the default solid background color. To give it a bit more personality, I want to generate this image on the fly by taking a screenshot and blurring it, instead. There's actually a patch that already does this, but the blur effect looks quite pixelated. So, I wrote my own version of this:

NOTE: As of Debian 13 (Trixie) the `/tmp` directory is now mounted using `tmpfs`. You can use this location as an alternative to `/dev/shm`, for correctness, given it's more appropriate for temporary files.

[source,bash]
----
#!/bin/bash

# Locks the current session, displaying a heavily blurred screenshot
# taken when the script runs.
#
# Requirements:
#   - scrot
#   - imagemagick
#   - slock + slock-background-image-20220318-1c5a538.diff

scrot - | convert - -blur 0x8 /dev/shm/slock.png // <1> <2>
slock
----
<1> Store this screenshot in a RAM-based file system for efficiency.
<2> By convention, when a command reads from a file, it should accept `-` as a replacement for standard input. The same is true for standard output when specifying the file location.

=== Crafting A Menu

To top it off we'll write a simple shell script that will present these options through `dmenu`:

[source,bash]
----
#!/bin/bash

# Presents the power options through dmenu and runs the selected action

selected=$(echo -ne "Lock Screen\nSuspend\nLog Out\nRestart\nPower Off" \
    | dmenu)

case "${selected}" in
    "Lock Screen")
        $HOME/.local/bin/lock.sh # <1>
        ;;
    "Suspend")
        $HOME/.local/bin/lock.sh # <2>
        sleep 4;
        systemctl suspend
        ;;
    "Power Off")
        systemctl poweroff
        ;;
    "Restart")
        systemctl reboot
        ;;
    "Log Out")
        pkill -u "$USER"
        ;;
esac
----
<1> That would be the script as shown above.
<2> Suspending does not automatically lock the screen by default.

You can have this script placed in your PATH, have a desktop file created for it or assign a keyboard shortcut to run it.

== Privilege Escalation

Switching to the root user account to run certain commands that require elevated privileges is the best way to go in terms of security. But it's a bit inconvenient for one-off tasks, and it would be nice to have that ability for at least a few selected commands.

This is what utilities like `sudo` are for, but perhaps you've noticed that this very common package is not already installed. We could do that, but in the pursuit of a minimalist system I think it's worth exploring a few alternatives.

=== sudo-rs

This one is not just yet another re-write of classic GNU/Linux utilities in the Rust programming languages. It's developed in collaboration with long time `sudo` maintainer Todd C. Miller, and it addresses several shortcomings of the original tool.

However, it's still under heavy development and has yet to see "real world usage" to polish all the rough edges. It also includes a lot of features that the average user probably needs (speaking strictly from a desktop user perspective).

Because of that, I prefer going with a more minimalistic approach.

=== OpenDoas

FreeBSD's `doas` ported to other UNIX systems. It's a much smaller code base, partly because it also offers fewer features in comparison to `sudo`, which helps reducing the attack surface. However, the main repository highlights that this is not a security guarantee:

"There are fewer eyes on random doas ports, just because sudo had a vulnerability does not mean random doas ports are more secure if they are not reviewed or PAM is configured incorrectly."
-- Duncan Overbruck, https://github.com/Duncaen/OpenDoas

With that in mind, let's install and configure it:

[source,console]
----
# apt install opendoas
----

The simplest configuration allows a regular user to run commands as the root user. We can do that:

[source,title=/etc/doas.conf]
----
permit persist :sudo as root # <1>
----
<1> Allows users in the "sudo" group to run commands as the root user.

This is equivalent to the default configuration of `sudo` on any Debian system, and should be enough for the majority of cases.
